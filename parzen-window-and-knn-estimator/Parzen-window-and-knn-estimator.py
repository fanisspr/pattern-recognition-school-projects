'''
The pdf of a random variable is given by: 
p(x)= 0.5, 0<x<2 
      0    otherwise

The pdf is estimated using the Parzen window and Knn estimators.
- Parzen window estimate uses a gaussian kernel, bandwidth of 0.05 and 0.2, 
  and is plotted using 32, 256 and 5000 points generated by a random number generator according to p(x)  
- Knn estimate uses k=32, 64, and 256 neighbors and is plotted using 5000 points.
'''
import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import KernelDensity


class ParzenWindow: 
    """
    A class for estimating the probability density of a 1D dataset 
    using the Parzen window method.

    Parameters
    ----------
    data : ndarray
        1D array of data points.
    """
    
    def __init__(self, data: np.ndarray) -> None:
        self.data = data


    #Parzen window density estimation, with gaussian kernel
    def fit(self, bandwidth: float, kernel: str ='gaussian') -> KernelDensity:
        """
        Fit a kernel density model using the Parzen window method.

        Parameters
        ----------
        bandwidth : float
            Bandwidth of the kernel.
        kernel : str, optional
            Type of kernel to use. Default is 'gaussian'.

        Returns
        -------
        pwde : KernelDensity
            Fitted kernel density model.
        """
        pwde = KernelDensity(kernel=kernel, bandwidth=bandwidth).fit(self.data.reshape(-1,1))
        return pwde


    #Evaluate the log density model on the points.
    def estimate(self, points_num: int, bandwidth: float) -> np.ndarray:
        """
        Estimate the probability density of the data using the kernel density model.

        Parameters
        ----------
        points_num : int
            Number of points to use for estimating the density.
        bandwidth : float
            Bandwidth of the kernel.

        Returns
        -------
        pdf_values : ndarray
            Array of estimated probability density values.
        """
        pwde = self.fit(bandwidth=bandwidth)
        points = np.linspace(-10, 10, points_num)
        pdf_values = np.exp(pwde.score_samples(points.reshape(-1,1)))
        return pdf_values
        

    def plot(self, points_num: int, 
             bandwidth: float, 
             pdf_values: np.ndarray, 
             ax) -> None:  
        """
        Plot the estimated density of the data using the kernel density model.

        Parameters
        ----------
        points_num : int
            Number of points to use for estimating the density.
        bandwidth : float
            Bandwidth of the kernel.
        pdf_values : ndarray
            Array of probability density values to plot.
        ax : matplotlib Axes
            Axes object to use for plotting.

        Returns
        -------
        None
            The estimated density is plotted using matplotlib.
        """          
        points = np.linspace(-10, 10, points_num)
        ax.plot(points, pdf_values, 'r.')
        ax.set(title=f"N= {points_num}, h= {bandwidth}", 
                xlabel='x',
                ylabel='pdf')


class KnnEstimator:
    """
    A class for estimating the probability density of a 1D dataset 
    using the k-nearest neighbors (KNN) method.

    Parameters
    ----------
    data : ndarray
        1D array of data points.
    """

    def __init__(self, data: np.ndarray) -> None:
        self.data = data


    def estimate(self, points_num: int, neighbors: int) -> np.ndarray:
        """
        Estimate the probability density of the data using the KNN method.

        Parameters
        ----------
        points_num : int
            Number of points to use for estimating the density.
        neighbors : int
            Number of nearest neighbors to use for estimating the density.

        Returns
        -------
        pdf : ndarray
            Array of estimated probability density values.
        """

        radius = []
        points = np.linspace(-10, 10, points_num)
        for p in points:
            distance = self.data - p
            distance = np.abs(distance)
            distance = np.sort(distance)
            radius.append(distance[neighbors])

        pdf = []
        for r in radius:
            est = neighbors / points_num * 0.5 / r
            pdf.append(est)
        return pdf


    def plot(self, points_num: int, 
             neighbors: int, 
             pdf_values: np.ndarray, 
             ax) -> None:  
        """
        Plot the estimated probability density of the data 
        using the KNN method.

        Parameters
        ----------
        points_num : int
            Number of points to use for estimating the density.
        neighbors : int
            Number of nearest neighbors to use for estimating the density.
        pdf_values : ndarray
            Array of probability density values to plot.
        ax : matplotlib Axes
            Axes object to use for plotting.

        Returns
        -------
        None
            The estimated density is plotted using matplotlib.
        """          
        points = np.linspace(-10, 10, points_num)
        ax.plot(points, pdf_values, 'b.')
        ax.set(title=f"N= {points_num}, k= {neighbors}",
                xlabel='x',
                ylabel='p(x)')


if __name__ == '__main__':
    # Points to estimate for
    N = [32, 256, 5000]
    # bandwidth
    h = [0.05, 0.2]

    fig, ax = plt.subplots(2, 3, figsize=(15, 10), sharex=True, sharey=True)
    fig.tight_layout(pad=3)

    for i, bandwidth in enumerate(h):
        for j, points in enumerate(N):
            # distribution: p=0.5 , 0<x<2
            data = np.random.uniform(0, 2, points)
            pw_estimator = ParzenWindow(data)
            pdf_values = pw_estimator.estimate(points, bandwidth)
            pw_estimator.plot(points, bandwidth, pdf_values, ax=ax[i, j])
    plt.show()
    fig.savefig('plots/Parzen-window-estimate.png')


    # Neighbors number list
    k = [32, 64, 256]
    # Points to estimate for
    N = 5000

    fig, ax = plt.subplots(1, 3, figsize=(15, 5), sharey=True)
    fig.tight_layout(pad=3)

    # distribution: p=0.5 , 0<x<2
    data = np.random.uniform(0, 2, N)
    for i, neighbors in enumerate(k):
        knn_estimator = KnnEstimator(data)
        # Estimate the density and get the probability density values
        pdf_values = knn_estimator.estimate(N, neighbors)
        knn_estimator.plot(N, neighbors, pdf_values, ax[i])
    plt.show()
    fig.savefig('plots/Knn-estimate.png')
